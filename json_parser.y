/* json_parser - bison grammar
 *
 * XXX This is VERY incomplete but the .info.json and .author.json files
 * generated by mkiocccentry do not cause any errors. Nothing is done with the
 * parsing but passing the input of .info.json or .author.json to this program
 * and you'll end up seeing e.g.:
 *
 *	./json_parser< test_work/12345678-1234-4321-abcd-1234567890ab-2/.info.json
 *
 *	[...]
 *	Now at end of input.
 *	Shifting token end of file ()
 *	Entering state 17
 *	Stack now 0 7 17
 *	Stack now 0 7 17
 *	Cleanup: popping token end of file ()
 *	Cleanup: popping nterm json ()
 *
 * In addition to the parser not doing anything there is missing grammar as
 * well; escaped characters are not handled for example.
 *
 * There are no actions yet. I'm not sure when I will be adding the actions and
 * it's very possible that I won't add all at once.
 *
 * A word about previous versions which had JSON_WHITESPACE. This caused
 * problems in that the parser expected whitespace which means that a lot of
 * different combinations would have to be added to the rules to get every
 * possible combination. It might be that whitespace has to be added to this
 * file but I'm not sure of this yet. Although json_parser.l has whitespace
 * defined it does not return the token as this will cause the parser to run
 * into problems on even the most basic json file.
 *
 * Something that's not addressed yet is strings can span newlines which is
 * invalid JSON. This will be addressed at another time.
 *
 * Additionally the memory returned by strdup() (json_parser.l action for
 * JSON_STRING) will not yet be freed but since the parser doesn't do anything
 * but just finishes until a parse error or EOF this is not a problem.
 *
 * I'm not sure when I will be adding more and I won't add all at once but
 * rather a bit each time. This is a work in progress!
 */

/* Section 1: Declarations */

/*
 * More detailed error reporting.
 *
 * NOTE: This is very verbose and will be removed when things are finished.
 */
%define parse.error detailed
%define parse.lac full
%{
#include <inttypes.h>
#include <stdio.h>

#include "json_parser.h"

int yylex(void);
void yyerror(char const *error, ...);
extern int yylineno;
extern char *yytext;
/* debug information during development */
#define YYDEBUG 1
int yydebug = 1;
%}

/*
 * Token types.
 *
 * It's very possible that this is incomplete and everything here is subject to
 * change.
 */

/* This union is NOT correct and it absolutely will change! */
%union json_type {
  char *string;
  uintmax_t uintmax;
  intmax_t number;
  bool boolean;
}
%token JSON_LETTER
%token JSON_SIGN JSON_EQUALS JSON_DIGIT JSON_DIGITS JSON_INTEGER JSON_EXPONENT
%token JSON_OPEN_BRACE JSON_CLOSE_BRACE JSON_OPEN_BRACKET JSON_CLOSE_BRACKET
%token JSON_COMMA JSON_COLON JSON_NULL
%token <string> JSON_STRING
%token <number> JSON_NUMBER
%token <boolean> JSON_BOOLEAN

/* Section 2: Rules
 *
 * Not all rules are here and no actions are defined yet. As well some of the
 * rules are probably wrong.
 *
 * Again this is very incomplete and there are errors!
 */
%%
json:		%empty |
		json_element
		;

json_value:	json_object |
		json_array  |
		JSON_STRING |
		JSON_NUMBER |
		JSON_BOOLEAN   |
		JSON_NULL
		;

json_object:	JSON_OPEN_BRACE json_members JSON_CLOSE_BRACE
		;

json_members:	json_member |
		json_member JSON_COMMA json_members
		;

json_member:	JSON_STRING JSON_COLON json_element
		;

json_array:	JSON_OPEN_BRACKET json_elements JSON_CLOSE_BRACKET
		;

json_elements:	json_element |
		json_element JSON_COMMA json_elements
		;

json_element:	json_value
		;



%%

/* Section 3: C code */
int
main(void)
{
    yyparse();
}

void
yyerror(char const *err, ...)
{
    /*
     * We use dbg() instead of err() but in the future it'll probably use the
     * jerr() function or some other error function. Right now it doesn't use
     * err() because I don't believe the seqcexit tool acts on .l/.y files so
     * the codes wouldn't be sequenced.
     *
     * Currently all you have to do to trigger this function being called is
     * typing anything after the program starts as once more it's incomplete!
     */
    dbg(DBG_NONE, "JSON parser error (num errors: %d): %s\n", yynerrs, err);
}

