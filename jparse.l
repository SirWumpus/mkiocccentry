/* vim: set tabstop=8 softtabstop=4 shiftwidth=4 noexpandtab : */
/* json_parser - flex grammar
 *
 * XXX This is VERY incomplete but the .info.json and .author.json files
 * generated by mkiocccentry do not cause any errors. No parse tree is generated
 * by the parser yet so no verification is done yet either.
 *
 * In addition to the parser not doing anything there is missing grammar and
 * there might be some grammar that's not correct. Not all actions are complete
 * and some that have been added do not yet check for errors.
 *
 * The JSON_STRING action that uses strdup() will be changed to use struct
 * string at a later date (sometime after struct json_string is finished). Similar
 * will be done for the numbers: struct integer and struct json_floating. These
 * structs are finished but will not be integrated until later on.
 *
 * I'm not sure when I will be adding more and I won't add all at once but
 * rather a bit each time. This is a work in progress!
 */

/* Section 1: Declarations and option settings */

/*
 * noyywrap prevents needing to link in the flex(1) library which means those
 * without flex can compile the code. Even if everyone had flex(1) though under
 * macOS you have to pass -ll to the compiler to link in the flex library
 * whereas in other systems you have to use -lfl which would cause a lot of
 * problems. Another way is to provide 'int yywrap() { return 1; }' but this is
 * unnecessary.
 */
%option noyywrap yylineno nodefault
/*
 * As we utterly object to the hideous code that bison and flex generate we
 * point it out in an ironic way by changing the prefix yy to ugly_.
 *
 * This means that for some symbols later in the file we use ugly_ instead of
 * yy. For example it's ugly_lval instead of yylval and best of all ugly_parse()
 * for it is an ugly parser.
 *
 * A negative consequence here is that because of the prefix being set to
 * ugly_ there's a typedef in the parser that _might suggest_ that _our struct
 * json_ is ugly:
 *
 *	typedef struct json UGLY_STYPE;
 *
 * At first glance this is a valid concern. However we argue that even if this
 * is so the struct might well have to be ugly because it's for a json parser; a
 * json parser necessarily has to be ugly due to the spec: one could easily be
 * forgiven for wondering if the author of the json specification was on drugs
 * at the time of writing.
 *
 * Please note that we're _ABSOLUTELY NOT_ saying that they were and we use the
 * term very loosely as well: we do not want to and we are not accusing anyone
 * of being on drugs (we rather find addiction a real tragedy and anyone with an
 * addition should be treated well and given the help they need) but the fact is
 * that the JSON specification is barmy and those who are in favour of it must
 * surely be in the JSON Barmy Army (otherwise known as the Barmy Army of the
 * Jocular Sillies On Narcotics :-)).
 *
 * Thus as much as we find the specification objectionable we rather feel sorry
 * for those who are indeed in the JSON Barmy Army and we apologise to them in a
 * light and fun way and we hope that they're not terribly humour impaired.

 */
%option prefix="ugly_"

/*
 * Currently disabled but this might be an idea when everything is in working
 * order. This will be determined once the parser is finished.
 *
 * %option nodefault
 */

%{
/* Declarations etc. go here.
 *
 * Code is copied verbatim near the top of the generated code.
 */

#include <stdio.h>

/* our header file */
#include "jparse.h"

YY_BUFFER_STATE bs;
void ugly_error(char const *format, ...);
%}

/*
 * Section 2: Patterns (regular expressions) and actions.
 */

/*
 * XXX JSON_WHITESPACE is not needed but for testing I have the whitespace here
 * and below in the actions print out that it is whitespace and what characters
 * (though newlines and other non-printable whitespace chars are not translated
 * to escape sequences). The text looks like:
 *
 *	whitespace: '<whitespace chars>'
 *
 * to help distinguish it from other patterns.
 */
JSON_WHITESPACE	[ \t\r\n]+

/*
 * NOTE: On the subject of JSON_STRING one might ask the question about the
 * tighter restrictions on JSON strings and why we don't even consider them.
 * This is a good question but the answer is simple: the JSON string conversion
 * routines actually do these checks. This simplifies the parser regex and so we
 * don't have to worry about complicating the parser unnecessarily.
 */
JSON_STRING		\"([^\n"]|\\\")*\"
JSON_INTEGER		-?([1-9][0-9]*|0)
JSON_FRACTION		"."[0-9]+
JSON_EXPONENT		[Ee][-+]?[0-9]+
JSON_NUMBER		({JSON_INTEGER}|{JSON_INTEGER}{JSON_FRACTION}|{JSON_INTEGER}{JSON_FRACTION}{JSON_EXPONENT})
JSON_TRUE		"true"
JSON_FALSE		"false"
JSON_NULL		"null"
JSON_OPEN_BRACE		"{"
JSON_CLOSE_BRACE	"}"
JSON_OPEN_BRACKET	"["
JSON_CLOSE_BRACKET	"]"
JSON_COLON		":"
JSON_COMMA		","

/* Actions.
 *
 * TODO: We have to do more than just assigning the token type (by which we mean
 * ugly_lval.type). These things will be done later.
 */
%%
{JSON_WHITESPACE}	    { printf("\nwhitespace: '%s'\n", yytext); }
{JSON_STRING}		    { printf("\nstring: '%s'\n", yytext); ugly_lval.type = JTYPE_STRING; return JSON_STRING; }
{JSON_NUMBER}		    { printf("\nnumber: '%s'\n", yytext); ugly_lval.type = JTYPE_NUMBER; return JSON_NUMBER; }
{JSON_NULL}		    { printf("\nnull: '%s'\n", yytext); ugly_lval.type = JTYPE_NULL; return JSON_NULL; }
{JSON_TRUE}		    { printf("\ntrue: '%s'\n", yytext); ugly_lval.type = JTYPE_BOOL; return JSON_TRUE; }
{JSON_FALSE}		    { printf("\nfalse: '%s'\n", yytext); ugly_lval.type = JTYPE_BOOL; return JSON_FALSE; }
{JSON_OPEN_BRACE}	    { printf("\nopen brace: '%c'\n", *yytext); token_type = '{'; return JSON_OPEN_BRACE; }
{JSON_CLOSE_BRACE}	    { printf("\nclose brace: '%c'\n", *yytext); token_type = '}'; return JSON_CLOSE_BRACE;}
{JSON_OPEN_BRACKET}	    { printf("\nopen bracket: '%c'\n", *yytext); token_type = '['; return JSON_OPEN_BRACKET; }
{JSON_CLOSE_BRACKET}	    { printf("\nclose bracket: '%c'\n", *yytext); token_type = ']'; return JSON_CLOSE_BRACKET; }
{JSON_COLON}		    { printf("\nequals/colon: '%c'\n", *yytext); token_type = ':'; return JSON_COLON; }
{JSON_COMMA}		    { printf("\ncomma: '%c'\n", *yytext); token_type = ','; return JSON_COMMA; }
.*			    { ugly_error("invalid input: %s\n", yytext); return JSON_INVALID_TOKEN; }
%%

/* Section 3: Code that's copied to the generated scanner */

/* parse_json_string	    - parse string as a JSON block
 *
 * given:
 *
 *	string	    - the string to parse as JSON
 *
 * NOTE: Until the JSON parser is finished this only parses the string (and not
 * necessarily correctly); it does NOT build a parse tree!
 *
 * NOTE: The reason this is in the scanner and not the parser is because
 * YY_BUFFER_STATE is part of the scanner and not the parser. There might be a
 * better way to go about this but I'll know about this more later on. Like
 * everything else here this is subject to change!
 *
 * NOTE: This function only warns on error. The reason for this is because more
 * than one string and/or file can then be verified during testing. Once the
 * parser is complete it will use jerr(). Note that this refers to errors
 * unspecific to the parser.
 */
void
parse_json_string(char const *string)
{
    /*
     * firewall
     */
    if (string == NULL) {
	/* this should never happen */
	warn(__func__, "passed NULL string");
	++num_errors;
	return;
    } else if (*string == '\0') /* strlen(string) == 0 */ {
	warn(__func__, "passed empty string");
	++num_errors;
	return;
    } else if (is_all_whitespace_str(string)) {
	warn(__func__, "string has only whitespace");
	++num_errors;
	return;
    }

    ugly_lineno = 1;
    bs = yy_scan_string(string);
    if (bs == NULL) {
	warn(__func__, "unable to scan string");
	++num_errors;
	return;
    }
    dbg(DBG_NONE, "*** BEGIN PARSE:\n'\n%s\n'", string);

    ugly_parse();

    yy_delete_buffer(bs);
    bs = NULL;

    dbg(DBG_NONE, "*** END PARSE");
    print_newline(output_newline);
}


/* parse_json_file	    - parses file file
 *
 * given:
 *
 *	filename    - filename to parse
 *
 * If filename is NULL or the filename is not a readable file (or is empty) or
 * if the file has embedded NUL bytes (not a C string) or if read_all() returns
 * NULL the function warns but does nothing else.
 *
 * NOTE: Until the JSON parser is finished this only parses the file (and not
 * necessarily correctly); it does NOT build a parse tree!
 *
 * NOTE: The reason this is in the scanner and not the parser is because
 * YY_BUFFER_STATE is part of the scanner and not the parser and that's required
 * for the parse_json_string() function so I think both ought to be here. There
 * might be a better way to go about that but I'll know more about this later
 * on. Like everything else here this is subject to change!
 *
 * NOTE: This function only warns on error. The reason for this is because more
 * than one string and/or file can then be verified during testing. Once the
 * parser is complete it will use jerr(). Note that this refers to errors
 * unspecific to the parser.
 */
void
parse_json_file(char const *filename)
{
    bool is_stdin = false;	/* true if reading from stdin (filename == "-") */
    char *data = NULL;		/* used to determine if there are NUL bytes in the file */
    size_t len = 0;		/* length of data read */

    /*
     * firewall
     */
    if (filename == NULL) {
	/* this should actually never happen if called from jparse */
	warn(__func__, "passed NULL filename");
	++num_errors;
	return;
    } else if (*filename == '\0') { /* strlen(filename) == 0 */
	warn(__func__, "passed empty filename");
	++num_errors;
	return;
    }

    is_stdin = !strcmp(filename, "-");
    if (!is_stdin && !is_file(filename)) {
	warn(__func__, "passed filename that's not actually a file: %s", filename);
	++num_errors;
	return;
    } else if (!is_stdin && !is_read(filename)) {
	warn(__func__, "passed filename not readable file: %s", filename);
	++num_errors;
	return;
    }

    errno = 0;
    yyin = is_stdin ? stdin : fopen(filename, "r");
    if (yyin == NULL) {
	warnp(__func__, "couldn't open file %s, ignoring", filename);
	++num_errors;
	return;
    }

    data = read_all(yyin, &len);
    if (data == NULL) {
	warn(__func__, "couldn't read in %s", is_stdin?"stdin":filename);
	++num_errors;
	clearerr_or_fclose(filename, yyin);
	return;
    }
    else if (len <= 0) {
	warn(__func__, "%s is empty", is_stdin?"stdin":filename);
	++num_errors;
	clearerr_or_fclose(filename, yyin);
	return;
    }
    else if (!is_string(data, len + 1)) {
	warn(__func__, "found embedded NUL byte in %s", is_stdin?"stdin":filename);
	++num_errors;
	clearerr_or_fclose(filename, yyin);
	return;
    } else if (is_all_whitespace_str(data)) {
	warn(__func__, "file has only whitespace");
	++num_errors;
	return;
    }

    dbg(DBG_NONE, "*** BEGIN PARSE:\n'\n%s\n'", data);

    /* free data */
    free(data);
    data = NULL;

    /* now parse the file */
    rewind(yyin);
    yyrestart(yyin);
    ugly_lineno = 1;
    ugly_parse();

    clearerr_or_fclose(filename, yyin);
    yyin = NULL;
    dbg(DBG_NONE, "*** END PARSE");
    print_newline(output_newline);

}
