/* json_parser - flex grammar
 *
 * XXX This is VERY incomplete but the .info.json and .author.json files
 * generated by mkiocccentry do not cause any errors. Nothing is done with the
 * parsing but passing the input of .info.json or .author.json to this program
 * and you'll end up seeing e.g.:
 *
 *	./json_parser< test_work/12345678-1234-4321-abcd-1234567890ab-2/.info.json
 *
 *	[...]
 *	Now at end of input.
 *	Shifting token end of file ()
 *	Entering state 17
 *	Stack now 0 7 17
 *	Stack now 0 7 17
 *	Cleanup: popping token end of file ()
 *	Cleanup: popping nterm json ()
 *
 * In addition to the parser not doing anything there is missing grammar and
 * there might be some grammar that's not correct. Not all actions are complete
 * and some that have been added do not yet check for errors.
 *
 * Additionally the memory returned by strdup() in the JSON_STRING action will
 * not yet be freed in the parser but since the parser doesn't do anything but
 * just finishes until a parse error or EOF this is not a problem.
 *
 * I'm not sure when I will be adding more and I won't add all at once but
 * rather a bit each time. This is a work in progress!
 *
 */

/* Section 1: Declarations and option settings */

/*
 * This prevents needing to link in the flex(1) library which means those
 * without flex can compile the code. Even if everyone had flex(1) though under
 * macOS you have to pass -ll to the compiler to link in the flex library
 * whereas in other systems you have to use -lfl which would cause a lot of
 * problems.
 */
%option noyywrap

%{
/* Declarations etc. go here.
 *
 * Code is copied verbatim near the top of the generated code.
 */

#include <stdio.h>

#include "util.h"
#include "dbg.h"

/* this is generated by bison */
#include "json_parser.tab.h"
void yyerror(char *s, ...);
extern int oldstate;
%}

/*
 * Section 2: Patterns (regular expressions) and actions.
 *
 * NOTE: There are likely errors here and it's probably incomplete as well.
 */
JSON_WHITESPACE         [ \t\r\n]+
JSON_STRING		\"[^"]*\"
JSON_DIGIT		[0-9]
JSON_DIGITS		{JSON_DIGIT}+
JSON_INTEGER		{JSON_DIGITS}
JSON_NUMBER		{JSON_DIGITS}"."?{JSON_DIGITS}*{JSON_EXPONENT}?
JSON_SIGN		[+-]
JSON_LETTER		[a-zA-Z]
JSON_EXPONENT		""?[Ee][-+]?[0-9]+
JSON_BOOLEAN		"true"|"false"
JSON_NULL		"null"
JSON_OPEN_BRACE		"{"
JSON_CLOSE_BRACE	"}"
JSON_OPEN_BRACKET	"["
JSON_CLOSE_BRACKET	"]"
JSON_COLON		":"
JSON_COMMA		","

/* Actions.
 *
 * For now we just print out what it is and return the type. Once again this is
 * incomplete!
 *
 * A word about previous versions which had JSON_WHITESPACE. This caused
 * problems in that the parser expected whitespace in specific places which
 * means that a lot of different combinations would have to be added to the
 * rules to get every possible combination. It might be that whitespace has to
 * be added to this file but I'm not sure of this yet. Whitespace does exist as
 * a type (above) but we don't do anything with it here with actions because
 * returning it to the parser causes parser errors.
 *
 * Something that's not addressed yet is strings can span newlines which is
 * invalid JSON. This will be addressed at another time.
 */
%%
{JSON_STRING}		    { printf("string: '%s'\n", yytext); yylval.string = strdup(yytext); return JSON_STRING; }
{JSON_NUMBER}		    { printf("number: '%s'\n", yytext); yylval.number = strtoimax(yytext, NULL, 10); return JSON_NUMBER; }
{JSON_NULL}		    { printf("null: '%s'\n", yytext); return JSON_NULL; }
{JSON_BOOLEAN}		    { printf("true: '%s'\n", yytext); yylval.boolean = string_to_bool(yytext); return JSON_BOOLEAN; }
{JSON_OPEN_BRACE}	    { printf("open brace: '%c'\n", *yytext); return JSON_OPEN_BRACE; }
{JSON_CLOSE_BRACE}	    { printf("close brace: '%c'\n", *yytext); return JSON_CLOSE_BRACE;}
{JSON_OPEN_BRACKET}	    { printf("open bracket: '%c'\n", *yytext); return JSON_OPEN_BRACKET; }
{JSON_CLOSE_BRACKET}	    { printf("close bracket: '%c'\n", *yytext); return JSON_CLOSE_BRACKET; }
{JSON_COLON}		    { printf("equals: '%c'\n", *yytext); return JSON_COLON; }
{JSON_COMMA}		    { printf("comma: '%c'\n", *yytext); return JSON_COMMA; }
.			    { printf("char: '%c'\n", *yytext); }
%%

/* Section 3: Code that's copied to the generated scanner */
