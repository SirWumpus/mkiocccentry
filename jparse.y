/* vim: set tabstop=8 softtabstop=4 shiftwidth=4 noexpandtab : */

/* JSON parser - bison grammar
 *
 * XXX This is VERY incomplete but the .info.json and .author.json files
 * generated by mkiocccentry do not cause any errors. No parse tree is generated
 * yet and so no verification is done yet either.
 *
 * XXX Once the parser is done test older versions of both bison and flex to see
 * if they can generate the proper code.
 *
 * This is a work in progress but as of the past few days (it's 16 May 2022 as I
 * write this) much progress has been made!
 */

/* Section 1: Declarations */
/*
 * We enable verbose error messages during development but once the parser is
 * complete we will disable this as it's very verbose.
 *
 * NOTE: Previously we used the -D option to bison because the %define is not
 * POSIX Yacc portable but we no longer do that because we make use of another
 * feature that's not POSIX Yacc portable that we deem worth it as it produces
 * easier to read error messages.
 */
%define parse.error verbose
/*
 * We enable lookahead correction parser for improved errors
 */
%define parse.lac full


/*
 * We use our struct json (see json_parse.h for its definition) instead of bison
 * %union.
 */
%define api.value.type {struct json *}

/*
 * we need access to the node in parse_json() so we tell bison that ugly_parse()
 * takes a struct json *node.
 */
%parse-param { struct json *node }

/*
 * An IOCCC satirical take on bison and flex
 *
 * As we utterly object to the hideous code that bison and flex generate we
 * point it out in an ironic way by changing the prefix yy to ugly_ so that
 * bison actually calls itself ugly. This is satire for the IOCCC (although we
 * still believe that bison generates ugly code)!
 *
 * This means that to access the struct json's union type in the lexer we can do
 * (because the prefix is ugly_ as described above):
 *
 *	ugly_lval.type = ...
 *
 * A negative consequence here is that because of the api.prefix being set to
 * ugly_ there's a typedef that _might_ suggest that _our_ struct json is ugly:
 *
 *	typedef struct json UGLY_STYPE;
 *
 * At first glance this is a valid concern. However we argue that even if this
 * is so the struct might well have to be ugly because it's for a json parser; a
 * json parser necessarily has to be ugly due to the spec: one could easily be
 * forgiven for wondering if the authors of the json specification were on drugs
 * at the time of writing them!
 *
 * Please note that we're _ABSOLUTELY NOT_ saying that they were and we use the
 * term very loosely as well: we do not want to and we are not accusing anyone
 * of being on drugs (we rather find addiction a real tragedy and anyone with an
 * addiction should be treated well and given the help they need) but the fact
 * is that the JSON specification is barmy and those who are in favour of it
 * must surely be in the JSON Barmy Army (otherwise known as the Barmy Army
 * Jointly Staying On Narcotics :-)).
 *
 * Thus as much as we find the specification objectionable we rather feel sorry
 * for those poor lost souls who are indeed in the JSON Barmy Army and we
 * apologise to them in a light and fun way and with hope that they're not
 * terribly humour impaired. :-)
 *
 * BTW: If you want to see all the symbols (re?)defined to something ugly run:
 *
 *	grep -i '#[[:space:]]*define[[:space:]].*ugly_' *.c
 *
 * after generating the files; and if you want to see only what was changed from
 * yy or YY to refer to ugly_ or UGLY_:
 *
 *	grep -i '#[[:space:]]*define[[:space:]]*yy.*ugly_' *.c
 *
 * This will help you find the right symbols should you need them. If (as is
 * likely to happen) the parser is split into another repo for a json parser by
 * itself I will possibly remove this prefix: this is as satire for the IOCCC
 * (though we all believe that the generated code is in fact ugly).
 *
 * WARNING: Although we use the prefix ugly_ the scanner and parser will at
 * times refer to yy and YY and other times refer to ugly_ and UGLY_ (partly
 * because WE refer to ugly_ and UGLY_). So if you're trying to sift through
 * that ugly spaghetti code (which we strongly recommend you do not do as it will
 * likely cause nightmares and massive brain pain) you'll want to check yy/YY as
 * well as ugly_/UGLY_. But really you oughtn't try and go through that code so
 * you need only pay attention to the ugly_ and UGLY_ prefixes (in the *.l and
 * *.y files) which again are satire for the IOCCC. See also the apology in the
 * generated files or directly looking at sorry.tm.ca.h.
 */
%define api.prefix {ugly_}

%{
#include <inttypes.h>
#include <stdio.h>
#include <unistd.h> /* getopt */
#include "jparse.h"

bool output_newline = true;		/* true ==> -n not specified, output new line after each arg processed */
unsigned num_errors = 0;		/* > 0 number of errors encountered */

/* debug information during development */
int ugly_debug = 1;

int token = 0;
%}


/*
 * Terminal symbols (token kind)
 *
 * For most of the terminal symbols we use string literals to identify them as
 * this makes it easier to read error messages. This feature is not POSIX Yacc
 * compatible but we've decided that the benefit outweighs this fact.
 */
%token JSON_OPEN_BRACE "{"
%token JSON_CLOSE_BRACE "}"
%token JSON_OPEN_BRACKET "["
%token JSON_CLOSE_BRACKET "]"
%token JSON_COMMA ","
%token JSON_COLON ":"
%token JSON_NULL "null"
%token JSON_TRUE "true"
%token JSON_FALSE "false"
%token JSON_STRING
%token JSON_NUMBER
%token JSON_INVALID_TOKEN


/*
 * Section 2: Rules
 *
 * See https://www.json.org/json-en.html for the JSON specification. We have
 * tried to make the below grammar as close to the JSON specification as
 * possible for those who are familiar with it but there might be some minor
 * differences in order or naming. One that we do not have is whitespace but
 * that's not needed and would actually cause many complications and parsing
 * errors. There are some others we do not need to include as well.
 *
 * XXX All the rules should be here but not all those that need actions have
 * actions. We also don't use the struct json *node yet (from parse_json()) but
 * this will have to change down the road.
 *
 * The actions are very much subject to change!
 */
%%
json:		    json_element
			{
			    /*
			     * $$ = $json
			     * $1 = $json_element
			     */
			    json_dbg(JSON_DBG_MED, __func__, "under json json_element:");
			    json_dbg(JSON_DBG_LOW, __func__, "under json: json_element: $json = $json_element");
			    $json = $json_element; /* magic: json becomes the json_element type */
			    json_dbg(JSON_DBG_LOW, __func__, "under json: json_element: $json type: %s", json_element_type_name($json));
			    json_dbg(JSON_DBG_LOW, __func__, "under json: json_element: $json_element type: %s", json_element_type_name($json_element));
			    json_dbg(JSON_DBG_MED, __func__, "under json: after json_element returning type: %s",
						   json_element_type_name($json));
			    json_dbg(JSON_DBG_LOW, __func__, "under json: after json_element before ;");
			}
		    ;

json_value:	    json_object
			{
			    /*
			     * $$ = $json_value
			     * $1 = $json_object
			     */
			    json_dbg(JSON_DBG_MED, __func__, "under json_value json_object:");
			    json_dbg(JSON_DBG_MED, __func__, "under json_value json_object: $json_value = $json_object");
			    $json_value = $json_object; /* magic: json_value becomes the json_object (JTYPE_OBJECT) type */
			    json_dbg(JSON_DBG_LOW, __func__, "under json_value: json_object: $json_value type: %s", json_element_type_name($json_value));
			    json_dbg(JSON_DBG_LOW, __func__, "under json_value: json_object: $json_object type: %s", json_element_type_name($json_object));
			    json_dbg(JSON_DBG_MED, __func__, "under json_value: after json_object returning type: %s",
						   json_element_type_name($json_value));
			    json_dbg(JSON_DBG_LOW, __func__, "under json_value: after json_object before |");
			}
		    |

		    json_array
			{
			    /*
			     * $$ = $json_value
			     * $1 = $json_array
			     */
			    json_dbg(JSON_DBG_MED, __func__, "under json_value json_array:");
			    $json_value = $json_array; /* magic: json_value becomes the json_array type (JTYPE_ARRAY) */
			    json_dbg(JSON_DBG_LOW, __func__, "under json_value: json_array: $json_value type: %s", json_element_type_name($json_value));
			    json_dbg(JSON_DBG_LOW, __func__, "under json_value: json_array: $json_array type: %s", json_element_type_name($json_array));
			    json_dbg(JSON_DBG_MED, __func__, "under json_value: after json_array returning type: %s",
						   json_element_type_name($json_value));
			    json_dbg(JSON_DBG_LOW, __func__, "under json_value: after json_array before |");
			}
		    |

		    json_string
			{
			    /*
			     * $$ = $json_value
			     * $1 = $json_string
			     */
			    json_dbg(JSON_DBG_MED, __func__, "under json_value json_string:");
			    $json_value = $json_string; /* magic: json_value becomes the json_string type (JTYPE_STRING) */
			    json_dbg(JSON_DBG_LOW, __func__, "under json_value: json_string: $json_value type: %s", json_element_type_name($json_value));
			    json_dbg(JSON_DBG_LOW, __func__, "under json_value: json_string: $json_string type: %s", json_element_type_name($json_string));
			    json_dbg(JSON_DBG_MED, __func__, "under json_value: after json_string returning type: %s",
						   json_element_type_name($json_value));
			    json_dbg(JSON_DBG_LOW, __func__, "under json_value: after json_string before |");
			}
		    |

		    json_number
			{
			    /*
			     * $$ = $json_value
			     * $1 = $json_number
			     */
			    json_dbg(JSON_DBG_MED, __func__, "under json_value json_number:");
			    $json_value = $json_number; /* magic: json_value becomes the json_number type (JTYPE_NUMBER) */
			    json_dbg(JSON_DBG_LOW, __func__, "under json_value: json_number: $json_value type: %s", json_element_type_name($json_value));
			    json_dbg(JSON_DBG_LOW, __func__, "under json_value: json_number: $json_number type: %s", json_element_type_name($json_number));
			    json_dbg(JSON_DBG_MED, __func__, "under json_value: after json_number returning type: %s",
						   json_element_type_name($json_value));
			    json_dbg(JSON_DBG_LOW, __func__, "under json_value: after json_number before |");
			}
		    |

		    JSON_TRUE
			{
			    /*
			     * $$ = $json_value
			     */
			    json_dbg(JSON_DBG_MED, __func__, "under json_value JSON_TRUE:");
			    $json_value = parse_json_bool(ugly_text); /* magic: json_value becomes the JSON_TRUE type (JTYPE_BOOL) */
			    json_dbg(JSON_DBG_MED, __func__, "$1 = %s", json_element_type_name($1));
			    json_dbg(JSON_DBG_LOW, __func__, "under json_value: JSON_TRUE: $json_value type: %s", json_element_type_name($json_value));
			    json_dbg(JSON_DBG_MED, __func__, "under json_value: after JSON_TRUE returning type: %s",
						   json_element_type_name($json_value));
			    json_dbg(JSON_DBG_LOW, __func__, "under json_value: after JSON_TRUE before |");
			}
		    |

		    JSON_FALSE
			{
			    /*
			     * $$ = $json_value
			     */
			    json_dbg(JSON_DBG_MED, __func__, "under json_value JSON_FALSE:");
			    $json_value = parse_json_bool(ugly_text); /* magic: json_value becomes the JSON_FALSE type (JTYPE_BOOL) */
			    json_dbg(JSON_DBG_LOW, __func__, "under json_value: JSON_FALSE: $json_value type: %s", json_element_type_name($json_value));
			    json_dbg(JSON_DBG_MED, __func__, "under json_value: after JSON_FALSE returning type: %s",
						   json_element_type_name($json_value));
			    json_dbg(JSON_DBG_LOW, __func__, "under json_value: after JSON_FALSE before |");
			}
		    |

		    JSON_NULL
			{
			    /*
			     * $$ = $json_value
			     */
			    json_dbg(JSON_DBG_MED, __func__, "under json_value JSON_NULL:");
			    $json_value = parse_json_null(ugly_text); /* magic: json_value becomes the JSON_NULL type (JTYPE_NULL) */
			    json_dbg(JSON_DBG_LOW, __func__, "under json_value: JSON_NULL: $json_value type: %s", json_element_type_name($json_value));
			    json_dbg(JSON_DBG_MED, __func__, "under json_value: after JSON_NULL returning type: %s",
						   json_element_type_name($json_value));
			    json_dbg(JSON_DBG_LOW, __func__, "under json_value: after JSON_NULL before ;");
			}
		    ;

json_object:	    JSON_OPEN_BRACE
			json_members
		    JSON_CLOSE_BRACE
			{
			    /*
			     * $$ = $json_object
			     * $1 = $json_members
			     */
			    json_dbg(JSON_DBG_MED, __func__, "under json_object: JSON_OPEN_BRACE json_members JSON_CLOSE_BRACE:");
			    json_dbg(JSON_DBG_LOW, __func__, "under json_object: $json_object type: %s", json_element_type_name($json_object));
			    json_dbg(JSON_DBG_LOW, __func__, "under json_object: $json_members type: %s", json_element_type_name($json_members));
			    json_dbg(JSON_DBG_LOW, __func__, "under json_object: need more code probably here"); /* XXX */
			    json_dbg(JSON_DBG_LOW, __func__, "under json_object: after JSON_CLOSE_BRACE before |");
			}
		    |

		    JSON_OPEN_BRACE
		    JSON_CLOSE_BRACE
			{
			    /*
			     * $$ = $json_object
			     */
			    json_dbg(JSON_DBG_MED, __func__, "JSON_OPEN_BRACE JSON_CLOSE_BRACE:");
			    $json_object = json_create_object(); /* json_object becomes JTYPE_OBJECT */
			    json_dbg(JSON_DBG_LOW, __func__, "under json_object: $json_object type: %s", json_element_type_name($json_object));
			    json_dbg(JSON_DBG_MED, __func__, "under json_object: after JSON_CLOSE_BRACE returning type: %s",
						   json_element_type_name($json_object));
			    json_dbg(JSON_DBG_LOW, __func__, "under json_object: after JSON_CLOSE_BRACE before ;");
			}
		    ;

json_members:	    json_member
			{
			    /*
			     * $$ = $json_members
			     * $1 = $json_member
			     */
			    json_dbg(JSON_DBG_MED, __func__, "under json_members: json_member:");
			    $json_members = $json_member; /* magic: json_members becomes the json_member type */
			    json_dbg(JSON_DBG_LOW, __func__, "under json_members: $json_members type: %s", json_element_type_name($json_members));
			    json_dbg(JSON_DBG_LOW, __func__, "under json_members: $json_member type: %s", json_element_type_name($json_member));
			    json_dbg(JSON_DBG_MED, __func__, "under json_members: after json_member returning type: %s",
						   json_element_type_name($json_members));
			    json_dbg(JSON_DBG_LOW, __func__, "under json_members: after json_member before |");
			}
		    |

		    json_members
			JSON_COMMA
		    json_member
			{
			    /*
			     * $$ = $json_members
			     * $1 = $json_member
			     *
			     * NOTE: Cannot use $json_members due to ambiguity.
			     * But we can use $1 for $json_member.
			     */
			    json_dbg(JSON_DBG_MED, __func__, "under json_members: json_members JSON_COMMA json_member:");
			    json_dbg(JSON_DBG_LOW, __func__, "under json_members: $$ type: %s", json_element_type_name($$));
			    json_dbg(JSON_DBG_LOW, __func__, "under json_members: $json_member type: %s", json_element_type_name($json_member));
			    json_dbg(JSON_DBG_LOW, __func__, "under json_members: need more code probably here"); /* XXX */
			    json_dbg(JSON_DBG_LOW, __func__, "under json_members: after json_member before ;");
			}
		    ;

json_member:	    json_string
			JSON_COLON
		    json_element
			{
			    /*
			     * $$ = $json_member
			     * $1 = $json_string
			     * $3 = $json_element
			     */
			    json_dbg(JSON_DBG_MED, __func__, "under json_member: json_string JSON_COLON json_element:");
			    json_dbg(JSON_DBG_LOW, __func__, "$json_member = parse_json_member($json_string = %s, $json_element = %s)",
				json_element_type_name($json_string), json_element_type_name($json_element));
			    $json_member = parse_json_member($json_string, $json_element);
			    json_dbg(JSON_DBG_LOW, __func__, "under json_member: $json_member type: %s", json_element_type_name($json_member));
			    json_dbg(JSON_DBG_MED, __func__, "under json_member: after json_element returning type: %s",
						   json_element_type_name($json_member));
			    json_dbg(JSON_DBG_LOW, __func__, "under json_member: after json_element before ;");
			}
		    ;

json_array:	    JSON_OPEN_BRACKET
			json_elements
		    JSON_CLOSE_BRACKET
			{
			    /*
			     * $$ = $json_array
			     * $2 = $json_elements
			     */
			    json_dbg(JSON_DBG_MED, __func__, "under json_array: JSON_OPEN_BRACKET json_elements JSON_CLOSE_BRACKET:");
			    json_dbg(JSON_DBG_LOW, __func__, "under json_array: $json_array type: %s", json_element_type_name($json_array));
			    json_dbg(JSON_DBG_LOW, __func__, "under json_array: $2 type: %s", json_element_type_name($json_elements));
			    json_dbg(JSON_DBG_LOW, __func__, "under json_array: need more code probably here"); /* XXX */
			    json_dbg(JSON_DBG_LOW, __func__, "under json_array: after JSON_CLOSE_BRACKET before |");
			}
		    |

		    JSON_OPEN_BRACKET
		    JSON_CLOSE_BRACKET
			{
			    /*
			     * $$ = $json_array
			     */
			    json_dbg(JSON_DBG_MED, __func__, "under json_array: JSON_OPEN_BRACKET JSON_CLOSE_BRACKET:");
			    $json_array = json_create_array();
			    json_dbg(JSON_DBG_LOW, __func__, "under json_array: $json_array type: %s", json_element_type_name($json_array));
			    json_dbg(JSON_DBG_MED, __func__, "under json_array: after JSON_CLOSE_BRACKET returning type: %s",
						   json_element_type_name($json_array));
			    json_dbg(JSON_DBG_LOW, __func__, "under json_array: after JSON_CLOSE_BRACKET before ;");
			}
		    ;


json_elements:	    json_element
			{
			    /*
			     * $$ = $json_elements
			     * $1 = $json_element
			     */
			    json_dbg(JSON_DBG_MED, __func__, "under json_elements: json_element:");
			    $json_elements = $json_element; /* magic: json_elements becomes the json_element type */
			    json_dbg(JSON_DBG_LOW, __func__, "under json_elements: $json_elements type: %s", json_element_type_name($json_elements));
			    json_dbg(JSON_DBG_LOW, __func__, "under json_elements: $json_element type: %s", json_element_type_name($json_element));
			    json_dbg(JSON_DBG_MED, __func__, "under json_elements: after json_element returning type: %s",
						   json_element_type_name($json_elements));
			    json_dbg(JSON_DBG_LOW, __func__, "under json_elements: after json_element before |");
			}
		    |

		    json_elements
			JSON_COMMA
		    json_element
			{
			    /*
			     * $$ = $json_elements
			     * $3 = $json_element
			     *
			     * NOTE: Cannot use $json_elements due to ambiguity.
			     * But we can use $3 for $json_element.
			     */
			    json_dbg(JSON_DBG_MED, __func__, "under json_elements: json_elements JSON_COMMA json_element:");
			    json_dbg(JSON_DBG_LOW, __func__, "under json_elements: $$ type: %s", json_element_type_name($$));
			    json_dbg(JSON_DBG_LOW, __func__, "under json_elements: $json_element type: %s", json_element_type_name($json_element));
			    json_dbg(JSON_DBG_LOW, __func__, "under json_elements: need more code probably here"); /* XXX */
			    json_dbg(JSON_DBG_LOW, __func__, "under json_elements: after json_element before ;");
			}
		    ;

json_element:	    json_value
			{
			    /*
			     * $$ = $json_element
			     * $1 = $json_value
			     */
			    json_dbg(JSON_DBG_MED, __func__, "under json_element: json_value:");
			    $json_element = $json_value; /* magic: json_element becomes the json_value type */
			    json_dbg(JSON_DBG_LOW, __func__, "under json_value: $json_element type: %s", json_element_type_name($json_element));
			    json_dbg(JSON_DBG_LOW, __func__, "under json_value: $json_value type: %s", json_element_type_name($json_value));
			    json_dbg(JSON_DBG_MED, __func__, "under json_element: after json_value returning type: %s",
						   json_element_type_name($json_element));
			    json_dbg(JSON_DBG_LOW, __func__, "under json_element: after json_value before ;");
			}
		    ;

json_string:	    JSON_STRING
			{
			    /*
			     * $$ = $json_string
			     */
			    json_dbg(JSON_DBG_MED, __func__, "under json_string: JSON_STRING:");
			    json_dbg(JSON_DBG_LOW, __func__, "$json_string = parse_json_string(%s, %d)",
				ugly_text, ugly_length);
			    $json_string = parse_json_string(ugly_text, ugly_length);
			    json_dbg(JSON_DBG_LOW, __func__, "under json_string: $json_string type: %s", json_element_type_name($json_string));
			    json_dbg(JSON_DBG_MED, __func__, "under json_string: after JSON_STRING returning type: %s",
						   json_element_type_name($json_string));
			    json_dbg(JSON_DBG_LOW, __func__, "under json_string: after JSON_STRING before ;");
			}
		    ;

json_number:	    JSON_NUMBER
			{
			    /*
			     * $$ = $json_number
			     */
			    json_dbg(JSON_DBG_MED, __func__, "under json_number: JSON_NUMBER:");
			    json_dbg(JSON_DBG_LOW, __func__, "$json_number = parse_json_number(%s)", ugly_text);
			    $json_number = parse_json_number(ugly_text);
			    json_dbg(JSON_DBG_LOW, __func__, "under json_number: $json_number type: %s", json_element_type_name($json_number));
			    json_dbg(JSON_DBG_MED, __func__, "under json_number: after JSON_NUMBER returning type: %s",
						   json_element_type_name($json_number));
			    json_dbg(JSON_DBG_LOW, __func__, "under json_number: after JSON_NUMBER before ;");
			}
		    ;




%%
/* Section 3: C code */

int
main(int argc, char **argv)
{
    char const *program = NULL;	    /* our name */
    extern char *optarg;	    /* option argument */
    extern int optind;		    /* argv index of the next arg */
    bool string_flag_used = false;  /* true ==> -S string was used */
    bool valid_json = false;	    /* true ==> JSON parse was valid */
    int ret;			    /* libc return code */
    int i;


    /*
     * XXX for development purposes we override the initial json_verbosity_level
     * to json_verbosity_level. This is used in json_vdbg() which is called by
     * json_dbg().
     *
     * This variable is used because it means we don't have to see debug
     * information unrelated to json if we don't want to - and it also prevents
     * the problem of other tools having this information printed if they don't
     * want it.
     *
     * On the other hand it also prevents other tools from seeing this
     * information until an option is added to set this level. I chose -J as
     * this seems like a good choice: with the exception of mkiocccentry no
     * other tool uses -j or -J and -J is a good letter for JSON specific
     * options. If mkiocccentry ever will need this option (which I can imagine
     * might well happen) another letter will have to be decided upon possibly
     * for all the tools.
     *
     * NOTE: This debug information is outside of the parser so until debugging
     * information in the parser is disabled you'll still see that upon using
     * jparse.
     *
     * NOTE: Because -s string parses the string at the time of seeing it one
     * must specify -J prior to -s if they want to change the debug level.
     */
    json_verbosity_level = JSON_DBG_LEVEL;
    /*
     * parse args
     */
    program = argv[0];
    while ((i = getopt(argc, argv, "hv:qVns:J:")) != -1) {
	switch (i) {
	case 'h':		/* -h - print help to stderr and exit 0 */
	    usage(2, "-h help mode", program); /*ooo*/
	    not_reached();
	    break;
	case 'v':		/* -v verbosity */
	    /*
	     * parse verbosity
	     */
	    verbosity_level = parse_verbosity(program, optarg);
	    break;
	case 'J': /* -J json_verbosity_level */
	    /*
	     * parse json verbosity level
	     */
	    json_verbosity_level = parse_verbosity(program, optarg);
	    break;
	case 'q':
	    msg_warn_silent = true;
	    ugly_debug = 0;
	    break;
	case 'V':		/* -V - print version and exit */
	    errno = 0;		/* pre-clear errno for warnp() */
	    ret = printf("%s\n", JPARSE_VERSION);
	    if (ret <= 0) {
		warnp(__func__, "printf error printing version string: %s", JPARSE_VERSION);
	    }
	    exit(0); /*ooo*/
	    not_reached();
	    break;
	case 'n':
	    output_newline = false;
	    break;
	case 's':
	    /*
	     * So we don't trigger missing arg. Maybe there's another way but
	     * nothing is coming to my mind right now.
	     */
	    string_flag_used = true;

	    json_dbg(json_verbosity_level, __func__, "Calling parse_json(\"%s\", %ju, NULL):",
					  optarg, (uintmax_t)strlen(optarg));
	    /* parse arg as a block of json input */
	    parse_json(optarg, strlen(optarg), &valid_json, stderr);
	    break;
	default:
	    usage(2, "invalid -flag or missing option argument", program); /*ooo*/
	    not_reached();
	}
    }

    /* perform IOCCC sanity checks */
    ioccc_sanity_chks();

    /*
     * case: process arguments on command line
     */
    if (argc - optind > 0) {

	/*
	 * process each argument in order
	 */
	for (i=optind; i < argc; ++i) {
	    parse_json_file(argv[i], &valid_json, stderr);
	}

    } else if (!string_flag_used) {
	usage(2, "-s string was not used and no file specified", program); /*ooo*/
	not_reached();
    }

    /*
     *  exit based on JSON parse success or failure
     */
    if (num_errors > 0 || valid_json == false) {
	exit(1); /*ooo*/
    }
    exit(0); /*ooo*/
}


/*
 * ugly_error	- generate an error message for the scanner/parser
 *
 * given:
 *
 *	node	    struct json * or NULL
 *	format	    printf style format string
 *	...	    optional parameters based on the format
 *
 */
void
ugly_error(struct json *node, char const *format, ...)
{
    va_list ap;		/* variable argument list */

    /*
     * we don't really need to do this (at least for now) but to demonstrate how
     * the function gets whatever the node from ugly_parse() (originating in
     * parse_json()) we just print out the node type.
     */
    if (node != NULL) {
	json_dbg(JSON_DBG_MED, __func__, "in ugly_error: node type: %s", json_element_type_name(node));
    }

    /*
     * stdarg variable argument list setup
     */
    va_start(ap, format);

    /*
     * We use fprintf and vfprintf instead of err() but in the future this might
     * use an error function of some kind, perhaps a variant of jerr() (a
     * variant because the parser cannot provide all the information that the
     * jerr() function expects). In the validation code we will likely use
     * jerr(). It's possible that the function jerr() will change as well but
     * this will be decided after the parser is complete.
     */
    fprintf(stderr, "JSON parser error on line %d: ", ugly_lineno);
    vfprintf(stderr, format, ap);
    fprintf(stderr, "\n");

    /*
     * stdarg variable argument list cleanup
     */
    va_end(ap);
}


/*
 * usage - print usage to stderr
 *
 * Example:
 *      usage(3, "missing required argument(s), program: %s", program);
 *
 * given:
 *	exitcode        value to exit with
 *	str		top level usage message
 *	program		our program name
 *
 * NOTE: We warn with extra newlines to help internal fault messages stand out.
 *       Normally one should NOT include newlines in warn messages.
 *
 * This function does not return.
 *
 */
static void
usage(int exitcode, char const *str, char const *prog)
{
    /*
     * firewall
     */
    if (str == NULL) {
	str = "((NULL str))";
	warn(__func__, "\nin usage(): program was NULL, forcing it to be: %s\n", str);
    }
    if (prog == NULL) {
	prog = "((NULL prog))";
	warn(__func__, "\nin usage(): program was NULL, forcing it to be: %s\n", prog);
    }

    /*
     * print the formatted usage stream
     */
    fprintf_usage(DO_NOT_EXIT, stderr, "%s\n", str);
    fprintf_usage(exitcode, stderr, usage_msg, prog, DBG_DEFAULT, json_verbosity_level, JPARSE_VERSION);
    exit(exitcode); /*ooo*/
    not_reached();
}
