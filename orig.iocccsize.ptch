#
# iocccsize.c patch
#
# The orig.ioccccsize.c is from:
#
#      https://github.com/SirWumpus/iocccsize/blob/master/iocccsize.c
#
# For this patch, orig.ioccccsize.c represents this GitHub commit:
#
#      https://github.com/SirWumpus/iocccsize/commit/1c65741901d0c863e3d6c0f73c0445d4e61b797b
#
# The occccsize.c is from:
#
#      https://github.com/ioccc-src/mkiocccentry
#
# For this patch, ioccccsize.c represents this GitHub commit:
#
#      https://github.com/ioccc-src/mkiocccentry/commit/c58d616d6288ebd08cbbad094d93bb14cfdfbb43
#
--- orig.iocccsize.c	2022-02-11 09:28:30.000000000 -0800
+++ iocccsize.c	2022-02-11 10:37:17.000000000 -0800
@@ -1,40 +1,33 @@
+/* vim: set tabstop=8 softtabstop=8 shiftwidth=8 noexpandtab : */
 /*
  * iocccsize - IOCCC Source Size Tool
  *
  *	"You are not expected to understand this" :-)
  *
  *	Public Domain 1992, 2015, 2018, 2019, 2021 by Anthony Howe.  All rights released.
- *	With IOCCC mods in 2019-2021 by chongo (Landon Curt Noll) ^oo^
+ *	With IOCCC mods in 2019-2022 by chongo (Landon Curt Noll) ^oo^
  *
  * SYNOPSIS
  *
- * 	iocccsize [-ihvV] prog.c
- * 	iocccsize [-ihvV] < prog.c
+ *	iocccsize [-ihvV] prog.c
+ *	iocccsize [-ihvV] < prog.c
  *
  *	-i	ignored for backward compatibility
- *	-h	print usage message in stderr and exit
+ *	-h	print usage message in stderr and exit 2
  *	-v	turn on some debugging to stderr; -vv or -vvv for more
- *	-V	print version and exit
+ *	-V	print version string and exit 3
  *
- *	The source is written to stdout, with possible translations ie. trigraphs.
- *	The IOCCC net count rule 2b is written to stderr; with -v, net count (2b),
- *	gross count (2a), number of keywords counted as 1 byte; -vv or -vvv write
+ *	The IOCCC net count rule 2b is written to stdout; with -v, net count (Rule 2b),
+ *	gross count (Rule 2a), number of keywords counted as 1 byte; -vv or -vvv write
  *	more tool diagnostics.
  *
- * DESCRIPION
+ * DESCRIPTION
  *
- *	Reading a C source file from standard input, apply the IOCCC
- *	source size rules as explained in the Guidelines.  The source
- *	code is passed through on standard output.  The source's net
- *	length is written to standard error; with -v option the net
- *	length, gross length, and matched keyword count are written.
- *
- *	The entry's gross size in bytes must be less than equal to 4096
- *	bytes in length.
- *
- *	The entry's net size in bytes must be less than equal to 2053
- *	bytes (first prime after 2048).  The net size is computed as
- *	follows:
+ *	Reading a C source file from standard input or a file arg, apply the IOCCC
+ *	source size rules as explained in the Guidelines.
+ *
+ *	The source's Rule 2b length is written to stdout; with -v option the Rule 2b
+ *	length, gross (Rule 2a) length, and matched keyword count are written to stdout.
  *
  *	The size tool counts most C reserved words (keyword, secondary,
  *	and selected preprocessor keywords) as 1.  The size tool counts all
@@ -43,9 +36,6 @@
  *	';', '{' or '}' octet immediately before the end of file.
  */
 
-#define DIGRAPHS
-#define TRIGRAPHS
-
 /*
  * IOCCC Judge's remarks:
  *
@@ -53,8 +43,11 @@
  * is RTFS (for certain values of RTFS).  One might say that this code
  * perfectly documents itself.  :-)
  *
- * Many thanks to Anthony Howe for taking the time to put his OCD
- * (Obfuscated Coding Determination) into this code!
+ * Many thanks to Anthony Howe for taking the time to put his OCD.
+ *
+ * For the original Anthony Howe source repo, please see:
+ *
+ *		https://github.com/SirWumpus/iocccsize
  */
 
 /*
@@ -79,53 +72,93 @@
 #include <string.h>
 #include <stdio.h>
 #include <stdlib.h>
+#include <errno.h>
 
-#ifndef VERSION
-#define VERSION "28.3 2021-12-29"	/* use format: major.minor YYYY-MM-DD */
-#endif
 
-#define WORD_BUFFER_SIZE	64
-#define MAX_SIZE		4096	/* IOCCC Rule 2a */
-#define MAX_COUNT		2053	/* IOCCC Rule 2b */
-#define STRLEN(s)		(sizeof (s)-1)
+/*
+ * iocccsize version string
+ */
+#define IOCCCSIZE_VERSION "28.7 2022-02-01"	/* use format: major.minor YYYY-MM-DD */
+char const * const iocccsize_version = IOCCCSIZE_VERSION;
 
-#define NO_STRING		0
-#define NO_COMMENT		0
-#define COMMENT_EOL		1
-#define COMMENT_BLOCK		2
 
-static char usage[] =
-"usage: iocccsize [-ihvV] prog.c\n"
-"       iocccsize [-ihvV] < prog.c\n"
+#if ! defined(MKIOCCCENTRY_USE)
+/*
+ * usage message, split into strings that are small enough to be supported by C standards
+ */
+static char usage0[] =
+"usage: iocccsize [-h] [-i] [-v ...] [-V] prog.c\n"
+"usage: iocccsize [-h] [-i] [-v ...] [-V] < prog.c\n"
 "\n"
 "-i\t\tignored for backward compatibility\n"
-"-h\t\tprint usage message in stderr and exit\n"
+"-h\t\tprint usage message in stderr and exit 2\n"
 "-v\t\tturn on some debugging to stderr; -vv or -vvv for more\n"
-"-V\t\tprint version and exit\n"
-"\n"
-"The source is written to stdout, with possible translations ie. trigraphs.\n"
-"The IOCCC net count rule 2b is written to stderr; with -v, net count (2b),\n"
+"-V\t\tprint version and exit 3\n"
+"\n";
+static char usage1[] =
+"The IOCCC net count Rule 2b is written to stdout; with -v, net count (2b),\n"
 "gross count (2a), number of keywords counted as 1 byte; -vv or -vvv write\n"
 "more tool diagnostics.\n"
-;
+"\n"
+"Exit codes:\n"
+"\t0 - source code is within Rule 2a and Rule 2b limits\n"
+"\t1 - source code larger than Rule 2a and/or Rule 2b limits\n"
+"\t2 - -h used and help printed\n"
+"\t3 - -V used and version printed\n"
+"\t>= 4 - some internal error occurred\n";
+#endif /* ! MKIOCCCENTRY_USE */
+
+
+#if defined(MKIOCCCENTRY_USE) || defined(IOCCCSIZE_STANDALONE)
+/*
+ * IOCCC size and rule related limitations
+ */
+#include "limit_ioccc.h"
+#include "util.h"
+
+#define STRLEN(s) LITLEN(s)
+
+# else /* MKIOCCCENTRY_USE || IOCCCSIZE_STANDALONE */
+
+/*
+ * IMPORTANT NOTE: The official IOCCC Rule 2a and Rule 2b values are found in:
+ *
+ *	https://github.com/ioccc-src/mkiocccentry/blob/master/limit_ioccc.h
+ *
+ * The RULE_2A_SIZE and RULE_2B_SIZE defines below are added for convience of
+ * compiling orig.iocccsize, only.  They are not official IOCCC Rule 2a and Rule 2b values.
+ * The same thing goes for DIGRAPHS and TRIGRAPHS.
+ */
+#define RULE_2A_SIZE		4096	/* IOCCC Rule 2a */
+#define RULE_2B_SIZE		2503	/* IOCCC Rule 2b */
+#undef DIGRAPHS				/* digraphs count a 2 for Rule 2b */
+#undef TRIGRAPHS			/* trigraphs count a 3 for Rule 2b */
+
+#define STRLEN(s)		(sizeof (s)-1)
+
+#endif /* MKIOCCCENTRY_USE || IOCCCSIZE_STANDALONE */
 
-static int debug;
-static char *out_fmt = "%lu\n";
+#define WORD_BUFFER_SIZE	256
+
+#define NO_STRING		0
+#define NO_COMMENT		0
+#define COMMENT_EOL		1
+#define COMMENT_BLOCK		2
 
 /*
  * C reserved words, plus a few #preprocessor tokens, that count as 1
  *
  * NOTE: For a good list of reserved words in C, see:
  *
- *	http://www.bezem.de/pdf/ReservedWordsInC.pdf
+ *	https://www.bezem.de/pdf/ReservedWordsInC.pdf
  *
  * by Johan Bezem of JB Enterprises:
  *
- *	See http://www.bezem.de/en/
+ *	See https://www.bezem.de/en/
  */
 typedef struct {
 	size_t length;
-	const char *word;
+	char const *word;
 } Word;
 
 static Word cwords[] = {
@@ -214,7 +247,7 @@
 };
 
 static Word *
-find_member(Word *table, const char *string)
+find_member(Word *table, char const *string)
 {
 	Word *w;
 	for (w = table; w->length != 0; w++) {
@@ -226,46 +259,50 @@
 }
 
 static int
-read_ch(FILE *fp)
+read_ch(FILE *fp, int *char_warning, int *nul_warning)
 {
 	int ch;
 
 	while ((ch = fgetc(fp)) != EOF && ch == '\r') {
 		/* Discard bare CR and those part of CRLF. */
 	}
-	if (ch == '\0' || 128 <= ch) {
-		errx(1, "NUL or non-ASCII characters");
+	if (128 <= ch) {
+		*char_warning = 1;
+	}
+	if (ch == '\0') {
+		*nul_warning = 1;
 	}
-
 	return ch;
 }
 
-static int
-rule_count(FILE *fp)
+struct iocccsize
+rule_count(FILE *fp, int debug)
 {
-	char word[WORD_BUFFER_SIZE];
-	size_t gross_count = 0, net_count = 0, keywords = 0, wordi = 0;
-	int ch, next_ch, quote = NO_STRING, escape = 0, is_comment = NO_COMMENT, rc = EXIT_SUCCESS;
+	char word[WORD_BUFFER_SIZE+1];
+	size_t wordi = 0;
+	int ch, next_ch, quote = NO_STRING, escape = 0, is_comment = NO_COMMENT;
+	struct iocccsize size;
 
 /* If quote == NO_STRING (0) and is_comment == NO_COMMENT (0) then its code. */
 #define IS_CODE	(quote == is_comment)
 
-	while ((ch = read_ch(fp)) != EOF) {
+	memset(&size, 0, sizeof(size));
+	while ((ch = read_ch(fp, &size.char_warning, &size.nul_warning)) != EOF) {
 		/* Future gazing. */
-		next_ch = read_ch(fp);
+		next_ch = read_ch(fp, &size.char_warning, &size.nul_warning);
 
 #ifdef TRIGRAPHS
 		if (ch == '?' && next_ch == '?') {
 			/* ISO C11 section 5.2.1.1 Trigraph Sequences */
-			const char *t;
-			static const char trigraphs[] = "=#([)]'^<{!|>}-~/\\";
+			char const *t;
+			static char const trigraphs[] = "=#([)]'^<{!|>}-~/\\";
 
 			ch = fgetc(fp);
 			for (t = trigraphs; *t != '\0'; t += 2) {
 				if (ch == t[0]) {
 					/* Mapped trigraphs count as 1 byte. */
 					next_ch = fgetc(fp);
-					gross_count += 2;
+					size.rule_2a_size += 2;
 					ch = t[1];
 					break;
 				}
@@ -274,7 +311,7 @@
 			/* Unknown trigraph, push back the 3rd character. */
 			if (*t == '\0') {
 				if (ch != EOF && ungetc(ch, fp) == EOF) {
-					errx(1, "ungetc error: bad \?\?%c trigraph", ch);
+					size.trigraph_warning = 1;
 				}
 				ch = '?';
 			}
@@ -284,7 +321,7 @@
 			/* ISO C11 section 5.1.1.2 Translation Phases
 			 * point 2 discards backslash newlines.
 			 */
-			gross_count += 2;
+			size.rule_2a_size += 2;
 			continue;
 		}
 
@@ -293,7 +330,7 @@
 			 * How does that relate to UTF8 and wide-character library
 			 * handling?  An invalid trigraph results in 2x ungetc().
 			 */
-			errx(1, "ungetc error: @SirWumpus goofed");
+			size.ungetc_warning = 1;
 		}
 
 		/* Within quoted string? */
@@ -338,10 +375,9 @@
 			is_comment = COMMENT_EOL;
 
 			/* Consume next_ch. */
-			(void) fputc(ch, stdout);
 			ch = fgetc(fp);
-			gross_count++;
-			net_count++;
+			size.rule_2a_size++;
+			size.rule_2b_size++;
 		}
 
 		/* Start of comment block? */
@@ -352,10 +388,9 @@
 			is_comment = COMMENT_BLOCK;
 
 			/* Consume next_ch. */
-			(void) fputc(ch, stdout);
 			ch = fgetc(fp);
-			gross_count++;
-			net_count++;
+			size.rule_2a_size++;
+			size.rule_2b_size++;
 		}
 
 		/* Open single or double quote? */
@@ -363,21 +398,18 @@
 			quote = ch;
 		}
 
-		(void) fputc(ch, stdout);
-
 #ifdef DIGRAPHS
 		/* ISO C11 section 6.4.6 Punctuators, digraphs handled during
 		 * tokenization, but map here and count as 1 byte, like their
 		 * ASCII counter parts.
 		 */
 		if (IS_CODE) {
-			const char *d;
-			static const char digraphs[] = "[<:]:>{<%}%>#%:";
+			char const *d;
+			static char const digraphs[] = "[<:]:>{<%}%>#%:";
 			for (d = digraphs; *d != '\0'; d += 3) {
 				if (ch == d[1] && next_ch == d[2]) {
-					(void) fputc(next_ch, stdout);
 					(void) fgetc(fp);
-					gross_count++;
+					size.rule_2a_size++;
 					ch = d[0];
 					break;
 				}
@@ -385,7 +417,7 @@
 		}
 #endif
 		/* Sanity check against file size and wc(1) byte count. */
-		gross_count++;
+		size.rule_2a_size++;
 
 		/* End of possible keyword?  Care with #word as there can
 		 * be whitespace or comments between # and word.
@@ -393,10 +425,10 @@
 		if ((word[0] != '#' || 1 < wordi) && !isalnum(ch) && ch != '_' && ch != '#') {
 			if (find_member(cwords, word) != NULL) {
 				/* Count keyword as 1. */
-				net_count = net_count - wordi + 1;
-				keywords++;
+				size.rule_2b_size = size.rule_2b_size - wordi + 1;
+				(size.keywords)++;
 				if (debug > 1) {
-					(void) fprintf(stderr, "~~keyword %zu \"%s\"\n", keywords, word);
+					(void) fprintf(stderr, "~~keyword %lu \"%s\"\n", (unsigned long)size.keywords, word);
 				}
 			}
 			word[wordi = 0] = '\0';
@@ -421,49 +453,32 @@
 		/* Collect next word not in a string or comment. */
 		if (IS_CODE && (isalnum(ch) || ch == '_' || ch == '#')) {
 			if (sizeof (word) <= wordi) {
-				warnx("word buffer overflow");
+				size.wordbuf_warning = 1;
 				wordi = 0;
 			}
 			word[wordi++] = (char) ch;
 			word[wordi] = '\0';
 		}
 
-		net_count++;
+		size.rule_2b_size++;
 	}
 
 	/*
-	 * The original author was not entirely in agreement with printing
-	 * these warnings, since he believes that its the programmer's job to
-	 * be cognisant of the rules, guidelines, and the state of their work.
-	 *
-	 * The IOCCC judges observe that enough IOCCC submitters are not so
-	 * cognizant (cognisant) and so make these warnings manditory in the
-	 * hopes it will reduce the number of entries that violate the IOCCC
-	 * size rules.
+	 * return stats
 	 */
-	if (MAX_SIZE < gross_count) {
-		if (debug == 0) {
-			(void) fprintf(stderr, "warning: size %zu exceeds Rule 2a %u\n", gross_count, MAX_SIZE);
-		}
-		rc = EXIT_FAILURE;
-	}
-	if (MAX_COUNT < net_count) {
-		if (debug == 0) {
-			(void) fprintf(stderr, "warning: count %zu exceeds Rule 2b %u\n", net_count, MAX_COUNT);
-		}
-		rc = EXIT_FAILURE;
-	}
-
-	(void) fprintf(stderr, out_fmt, net_count, gross_count, keywords);
-
-	return rc;
+	return size;
 }
 
+#if !defined(MKIOCCCENTRY_USE)
 int
 main(int argc, char **argv)
 {
-	int ch, rc;
+	FILE *fp = stdin;		/* stream from which to determine sizes */
+	struct iocccsize size;		/* rule_count() processing results */
+	int debug = 0;
+	int ch;
 
+	memset(&size, 0, sizeof(size));
 	while ((ch = getopt(argc, argv, "6ihvV")) != -1) {
 		switch (ch) {
 		case 'i': /* ignored for backward compatibility */
@@ -471,41 +486,85 @@
 
 		case 'v':
 			debug++;
-			out_fmt = "%lu %lu %lu\n";
 			break;
 
 		case 'V':
-			printf("%s\n", VERSION);
-			exit(0);
+			printf("%s\n", iocccsize_version);
+			exit(3);
 
 		case '6': /* You're a RTFS master!  Congrats. */
 			errx(6, "There is NO... Rule 6!  I'm not a number!  I'm a free(void *man)!");
 
 		case 'h':
+			fprintf(stderr, "%s%s", usage0, usage1);
+			exit(2);
+			break;
+
 		default:
-			fprintf(stderr, "%s", usage);
-			return 2;
+			fprintf(stderr, "unknown -option\n");
+			fprintf(stderr, "%s%s", usage0, usage1);
+			exit(4);
+			break;
 		}
 	}
 
 	if (optind + 1 == argc) {
 		/* Redirect stdin to file path argument. */
-		if (freopen(argv[optind], "r", stdin) == NULL) {
-			err(3, "%s", argv[optind]);
+		errno = 0;
+		fp = fopen(argv[optind], "r");
+		if (fp == NULL) {
+			fprintf(stderr, "freopen(%s) failed: %s\n", argv[optind], strerror(errno));
+			exit(5);
 		}
 	} else if (optind != argc) {
 		/* Too many arguments. */
-		fprintf(stderr, "%s", usage);
-		return 2;
+		fprintf(stderr, "%s%s", usage0, usage1);
+		exit(4);
 	}
 
-	(void) setvbuf(stdin, NULL, _IOLBF, 0);
+	(void) setvbuf(fp, NULL, _IOLBF, 0);
 
 	/* The Count - 1 Muha .. 2 Muhaha .. 3 Muhahaha ... */
-	rc = rule_count(stdin);
+	size = rule_count(fp, debug);
+	if (debug == 0) {
+		(void) printf("%ld\n", (unsigned long)size.rule_2b_size);
+	} else {
+		(void) printf("%ld %ld %ld\n", (unsigned long)size.rule_2b_size, (unsigned long)size.rule_2a_size,
+					       (unsigned long)size.keywords);
+	}
+
+	/*
+	 * issue warnings
+	 */
+	if (size.char_warning) {
+		fprintf(stderr, "Warning: character(s) with high bit set found! Be careful you don't violate rule 13!\n");
+	}
+	if (size.nul_warning) {
+		fprintf(stderr, "Warning: NUL character(s) found! Be careful you don't violate rule 13!\n");
+	}
+	if (size.trigraph_warning) {
+		fprintf(stderr, "Warning: unknown or invalid trigraph(s) found! Is that a bug in, or a feature of your code?\n");
+	}
+	if (size.wordbuf_warning) {
+		fprintf(stderr, "Warning: word buffer overflow! Is that a bug in, or a feature of your code?\n");
+	}
+	if (size.ungetc_warning) {
+		fprintf(stderr, "Warning: ungetc error: @SirWumpus goofed. The size on stdout may be invalid under rule 2!\n");
+	}
+	if (size.rule_2a_size > RULE_2A_SIZE) {
+		(void) fprintf(stderr, "Warning: your source under Rule 2a: %lu exceeds Rule 2a limit: %lu: Rule 2a violation!\n",
+				       (unsigned long)size.rule_2a_size, (unsigned long)RULE_2A_SIZE);
+		exit(1);
+	}
+	if (size.rule_2b_size > RULE_2B_SIZE) {
+		(void) fprintf(stderr, "Warning: your source under Rule 2b: %lu exceeds Rule 2b limit: %lu: Rule 2b violation!\n",
+				       (unsigned long)size.rule_2b_size, (unsigned long)RULE_2B_SIZE);
+		exit(1);
+	}
 
 	/*
 	 * All Done!!! All Done!!! -- Jessica Noll, age 2
 	 */
-	return rc;
+	exit(0);
 }
+#endif /* ! MKIOCCCENTRY_USE */
